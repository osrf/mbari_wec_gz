#!/usr/bin/python3
# Copyright 2022 Open Source Robotics Foundation, Inc. and Monterey Bay Aquarium Research Institute
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Launch batch of buoy simulations."""

from em import invoke as empy
import numpy as np
import yaml

import os
import shutil
import sys
import time

from ament_index_python.packages import get_package_share_directory

from launch import LaunchDescription
from launch import LaunchService
from launch.actions import ExecuteProcess, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource

import rclpy
from rclpy.node import Node


PHYSICS_MAX_STEP_SIZE = 0.001  # seconds

class MonoChromatic(object):
    def __init__(self, A, T):
        self.A, self.T = A, T
        self.name = "MonoChromatic"
    def __str__(self):
        if self.A is not None:
            return f'{self.name};A:{self.A};T:{self.T}'
        else:
            return f'{self.name};A:default;T:default'

class Bretschneider(object):
    def __init__(self, Hs, Tp):
        self.Hs, self.Tp = Hs, Tp
        self.name = "Bretschneider"
    def __str__(self):
        if self.Hs is not None:
            return f'{self.name};Hs:{self.Hs};Tp:{self.Tp}'
        else:
            return f'{self.name};Hs:default;Tp:default'

class Custom(object):
    def __init__(self, w, Szz):
        self.w, self.Szz = w, Szz
        self.name = "Custom"
    def __str__(self):
        if self.w is not None:
            return f'{self.name};' + \
                   f'w:{":".join([str(w) for w in self.w])};' + \
                   f'Szz:{":".join([str(Szz) for Szz in self.Szz])}'
        else:
            return f'{self.name};w:defaults;Szz:defaults'


def generate_simulations(sim_params_yaml):

    rclpy.init()
    node = Node('mbari_wec_batch')

    with open(sim_params_yaml, 'r') as fd:
        sim_params = yaml.load(fd, Loader=yaml.CLoader)

    # Grab params from yaml
    # seed (random seed for incident waves plugin)
    try:
        if 'seed' in sim_params:
            seed = int(sim_params['seed'])
        else:
            seed = None
            node.get_logger().warn('sim_params_yaml: optional seed parameter not specified')
    except TypeError as err:
        node.get_logger().error('sim_params_yaml: seed parameter' +
                                ' must be a single value')
        sys.exit(-1)

    # duration (seconds)
    try:
        if 'duration' not in sim_params:
            node.get_logger().error('sim_params_yaml: required duration parameter not specified')
            sys.exit(-1)
        duration = float(sim_params['duration'])
    except TypeError as err:
        node.get_logger().error('sim_params_yaml: duration parameter' +
                                ' must be a single value in seconds')
        sys.exit(-1)

    # convert duration to iterations
    iterations = int(round(duration / PHYSICS_MAX_STEP_SIZE))

    # door state ('open', 'closed')
    if 'door_state' in sim_params:
        door_state = sim_params['door_state']
        if any(['open' not in ds and 'closed' not in ds for ds in door_state]):
            node.get_logger().error(
                "sim_params_yaml: all door_state parameters must be either 'open' or 'closed'"
            )
            sys.exit(-1)
    else:
        node.get_logger().warn(
            "sim_params_yaml: door_state parameter not specified -- defaulting to 'closed'"
        )
        door_state = ['closed']

    # scale factor (0.5 - 1.4)
    if 'scale_factor' in sim_params:
        scale_factor = np.array(sim_params['scale_factor'], dtype=float)
        if not np.all((0.5 <= scale_factor) & (scale_factor <= 1.4)):
            node.get_logger().error(
                'sim_params_yaml: all scale_factor parameters must be between 0.5 to 1.4'
            )
            sys.exit(-1)
    else:
        node.get_logger().warn(
            'sim_params_yaml: scale_factor parameter not specified -- defaulting to 1.0'
        )
        scale_factor = [1.0]

    # Battery State
    # State of Charge (0.0 [270V] to 1.0 [320V])
    if 'battery_soc' in sim_params:
        battery_state = np.array(sim_params['battery_soc'], dtype=float)
        if np.all((0.0 <= battery_state) & (battery_state <= 1.0)):
            batt_state_type = 'SoC'
        else:
            node.get_logger().error(
                'sim_params_yaml: all battery_soc parameters must be between 0.0 to 1.0'
            )
            sys.exit(-1)
    # EMF (270V to 320V)
    elif 'battery_emf' in sim_params:
        battery_state = np.array(sim_params['battery_emf'], dtype=float)
        if np.all((270.0 <= battery_state) & (battery_state <= 300.0)):
            batt_state_type = 'EMF'
        else:
            node.get_logger().error(
                f'sim_params_yaml: all battery_emf parameters must be between 300V to 270V'
            )
            sys.exit(-1)
    else:
        node.get_logger().warn(
            f'sim_params_yaml: optional battery_emf or battery_soc parameter not specified'
        )
        battery_state = [None]
        batt_state_type = ''

    # IncWaveSpectrumType
    if 'IncidentWaveSpectrumType' in sim_params:
        inc_wave_spectrum_types = sim_params['IncidentWaveSpectrumType']
        incident_waves = []
        for inc_wave_spectrum_type in inc_wave_spectrum_types:
            if 'MonoChromatic' in inc_wave_spectrum_type:
                monochromatic_spectrum = inc_wave_spectrum_type['MonoChromatic']
                if 'A' in monochromatic_spectrum:
                    A = float(monochromatic_spectrum['A'])
                else:
                    A = None
                if 'T' in monochromatic_spectrum:
                    T = float(monochromatic_spectrum['T'])
                else:
                    T = None

                if (A is None) ^ (T is None):
                    node.get_logger().error(
                        'sim_params_yaml: MonoChromatic: A or T unspecified.' +
                        ' Please specify both or neither'
                    )
                    sys.exit(-1)
                incident_waves.append(MonoChromatic(A, T))
            elif 'Bretschneider' in inc_wave_spectrum_type:
                bretschneider_spectrum = inc_wave_spectrum_type['Bretschneider']
                if 'Hs' in bretschneider_spectrum:
                    Hs = float(bretschneider_spectrum['Hs'])
                else:
                    Hs = None
                if 'Tp' in bretschneider_spectrum:
                    Tp = float(bretschneider_spectrum['Tp'])
                else:
                    Tp = None

                if (Hs is None) ^ (Tp is None):
                    node.get_logger().error(
                        'sim_params_yaml: Bretschneider: Hs or Tp unspecified.' +
                        ' Please specify both or neither'
                    )
                    sys.exit(-1)
                incident_waves.append(Bretschneider(Hs, Tp))
            elif 'Custom' in inc_wave_spectrum_type:
                custom_spectrum = inc_wave_spectrum_type['Custom']
                if 'w' in custom_spectrum:
                    w = np.array(custom_spectrum['w'], dtype=float)
                else:
                    w = None
                if 'Szz' in custom_spectrum:
                    Szz = np.array(custom_spectrum['Szz'], dtype=float)
                else:
                    Szz = None

                if (w is None) ^ (Szz is None):
                    node.get_logger().error(
                        'sim_params_yaml: Custom: w or Szz unspecified.' +
                        ' Please specify both or neither'
                    )
                    sys.exit(-1)
                if w is not None and Szz is not None:
                    if w.shape != Szz.shape:
                        node.get_logger().error(
                            'sim_params_yaml: Custom: w.shape != Szz.shape'
                        )
                        sys.exit(-1)
                incident_waves.append(Custom(w, Szz))
            else:
                node.get_logger().error(
                    f'sim_params_yaml: IncWaveSpectrumType [{inc_wave_spectrum_type}]' +
                    ' did not match supported types:\n    ' +
                    '\n    '.join(['MonoChromatic', 'Bretschneider', 'Custom'])
                )
                sys.exit(-1)
    else:
        node.get_logger().warn(
            'sim_params_yaml: optional IncWaveSpectrumType parameter not specified' +
            ' -- defaulting to No Waves'
        )
        incident_waves = [None]

    # create batch results directory
    timestr = time.strftime("%Y%m%d%H%M%S")
    batch_results_dir = f'batch_results_{timestr}'
    node.get_logger().info(f'Creating batch results directory: {batch_results_dir}')
    os.makedirs(batch_results_dir)

    sim_params_name, dot_yaml = os.path.splitext(os.path.basename(sim_params_yaml))
    sim_params_date_yaml = sim_params_name + f'_{timestr}' + dot_yaml
    node.get_logger().debug('Copying sim params yaml to batch results directory: ' +
                            os.path.join(batch_results_dir,
                                         sim_params_date_yaml))
    shutil.copy(sim_params_yaml,
                os.path.join(batch_results_dir,
                             sim_params_date_yaml))

    # generate test matrix
    batch_params = list(zip(*[param.ravel() for param in np.meshgrid(door_state,
                                                                     scale_factor,
                                                                     battery_state,
                                                                     incident_waves)]))

    node.get_logger().info(f'Generated {len(batch_params)} simulation runs')
    node.get_logger().debug('Seed, Duration, Door State, Scale Factor, Battery State' +
                            ', IncWaveSpectrumType;IncWaveSpectrumParams')
    [node.get_logger().debug(f'{seed if seed is not None else ""}, {duration}, {ds}, {sf}' +
                             f', {bs if bs is not None else ""}' +
                             f', {str(iw) if iw is not None else ""}')
        for ds, sf, bs, iw in batch_params]

    node.get_logger().info('Creating log file: ' +
                           os.path.join(batch_results_dir, f'batch_runs_{timestr}.log'))
    with open(os.path.join(batch_results_dir, f'batch_runs_{timestr}.log'), 'w') as fd:
        fd.write(f'# Generated {len(batch_params)} simulation runs\n')
        fd.write('Run Index, Start Time, rosbag2 File Name,' +
                 ' Seed, Duration, Door State, Scale Factor, Battery State' +
                 ', IncWaveSpectrumType;IncWaveSpectrumParams\n')

    # Find packages
    pkg_buoy_gazebo = get_package_share_directory('buoy_gazebo')
    pkg_buoy_description = get_package_share_directory('buoy_description')

    # Find model templates
    model_dir = 'mbari_wec_base'
    empy_base_sdf_file = os.path.join(pkg_buoy_description, 'models', model_dir, 'model.sdf.em')
    base_sdf_file = os.path.join(pkg_buoy_description, 'models', model_dir, 'model.sdf')

    model_dir = 'mbari_wec'
    empy_sdf_file = os.path.join(pkg_buoy_description, 'models', model_dir, 'model.sdf.em')
    sdf_file = os.path.join(pkg_buoy_description, 'models', model_dir, 'model.sdf')

    # Start batch runs
    for idx, (ds, sf, bs, iw) in enumerate(batch_params):
        node.get_logger().info(f'\n\nSim run [{idx}] for {duration} seconds:' +
                               f" door state='{ds}', scale factor={sf}" +
                               f", battery state={bs if bs is not None else 'None'}" +
                               ", IncidentWaveSpectrumType=" +
                               f"{str(iw) if iw is not None else 'None'}\n")

        # fill mbari_wec_base model template with params
        empy(['-D', f"door_state = '{ds}'",
              '-o', base_sdf_file,
              empy_base_sdf_file])

        # fill mbari_wec model template with params
        mbari_wec_model_params = ['-D', f'scale_factor = {sf}']
        if seed is not None:
            mbari_wec_model_params.extend(['-D', f'inc_wave_seed = {seed}'])
        if bs is not None:
            if 'SoC' in batt_state_type:
                mbari_wec_model_params.extend(['-D', f'battery_soc = {bs}'])
            elif 'EMF' in batt_state_type:
                mbari_wec_model_params.extend(['-D', f'battery_emf = {bs}'])
        if iw is not None:
            mbari_wec_model_params.extend(['-D', f'inc_wave_spectrum_type = "{iw.name}"'])
            if 'MonoChromatic' in iw.name:
                if iw.A is not None:
                    mbari_wec_model_params.extend(['-D', f'A = {iw.A}'])
                    mbari_wec_model_params.extend(['-D', f'T = {iw.T}'])
            if 'Bretschneider' in iw.name:
                if iw.Hs is not None:
                    mbari_wec_model_params.extend(['-D', f'Hs = {iw.Hs}'])
                    mbari_wec_model_params.extend(['-D', f'Tp = {iw.Tp}'])
            if 'Custom' in iw.name:
                if iw.w is not None:
                    mbari_wec_model_params.extend(['-D', f'w = {iw.w.tolist()}'])
                    mbari_wec_model_params.extend(['-D', f'Szz = {iw.Szz.tolist()}'])
        mbari_wec_model_params.extend(['-o', sdf_file,
            empy_sdf_file])
        node.get_logger().debug(mbari_wec_model_params)
        empy(mbari_wec_model_params)

        node.get_logger().debug('running gz-sim with gz_args:=' +
                               '-rs' +
                              f' --iterations {iterations}')

        # Dynamically create launch file
        def generate_launch_description():
            mbari_wec = IncludeLaunchDescription(
                PythonLaunchDescriptionSource(
                    os.path.join(pkg_buoy_gazebo, 'launch', 'mbari_wec.launch.py'),
                ),
                launch_arguments={'extra_gz_args': '-rs' +
                                                  f' --iterations {iterations}'
                                 }.items(),
            )

            # record all topics with rosbag2
            start_time = time.strftime("%Y%m%d%H%M%S")
            rosbag2_name = f'rosbag2_batch_sim_{idx}_{start_time}'
            rosbag2 = ExecuteProcess(
                cmd=['ros2', 'bag', 'record',
                     '-o', os.path.join(batch_results_dir, rosbag2_name), '-a'],
                output='screen'
            )

            # Write to log
            with open(os.path.join(batch_results_dir, f'batch_runs_{timestr}.log'), 'a') as fd:
                fd.write(f'{idx}, {start_time}, {rosbag2_name}' +
                         f', {seed if seed is not None else ""}, {duration}, {ds}, {sf}' +
                         f', {bs if bs is not None else ""}'
                         f', {str(iw) if iw is not None else ""}\n')

            return LaunchDescription([
                rosbag2,
                mbari_wec
            ])

        # Launch sim instance
        ls = LaunchService()
        ls.include_launch_description(generate_launch_description())
        result = ls.run()
        if result:
            node.get_logger().error(f'Simulation run [{idx}] was not successful: ' +
                                    f'return code [{result}]')

if __name__=='__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Batch running for buoy_sim')
    parser.add_argument('sim_params_yaml',
                        help='yaml file with batch parameters')
    args, unknown = parser.parse_known_args()
    generate_simulations(args.sim_params_yaml)
